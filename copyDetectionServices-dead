import { AppContext } from "./src/common/appTypes";
const token =
  "ya29.a0AXeO80Tes-_7MohnwFmYq79LGAmd_9Y4dC0hxrLH2BRFogJEtDr62p6Wfbdoi3C2UQ3WTXqdaHKxLdLqgBmLO37BeO6J3djQDyAOwJabAWOszBz870oSlQj22FOA4SsjUkK3Lu1-4gRKVXQ0Finuii5sZGiutz86xkOpLKrBMMrqPAPGjAWmAYmS0gaCgYKARISARASFQHGX2MiFm-KVvb9UnbosTtFaMeoAQ0193";
const fileId = "1FD4A2TCecTWaDxUOAq9nrDIp_TLcZGNA8Y_gSrj8FBE";
const testUrl = `https://docs.google.com/document/d/${fileId}/revisions/tiles?id=${fileId}&start=1&showDetailedRevisions=false&token=${token}`;
console.log(testUrl);
// Define necessary types
interface RevisionData {
  ty: string; // Type of event (e.g., "is" for insert, "ds" for delete)
  timestamp: number;
  s?: string; // Text inserted
  ibi?: number; // Index before insert
  si?: number; // Start index for delete
  ei?: number; // End index for delete
  pasted?: boolean; // Indicates pasted text
  outsidePasted?: number; // 1 if pasted from external source
  elapsedTime?: number; // Time spent on this revision step
  isDeleted?: boolean; // Indicates deleted characters
}

interface TimeStats {
  hours: number;
  minutes: number;
  rawElapsedTime: number;
}

// Function to fetch the total number of revisions
async function fetchTotalRevisions(
  docId: string,
  token: string
): Promise<number> {
  const url = `https://www.googleapis.com/drive/v3/files/${docId}/revisions?fields=revisions(id)`;

  try {
    const response = await fetch(url, {
      method: "GET",
      headers: {
        Authorization: `Bearer ${token}`,
        Accept: "application/json",
      },
    });

    const data = await response.json();
    if (!data.revisions || data.revisions.length === 0)
      throw new Error("No revisions found.");

    return data.revisions.length; // Get the latest revision count
  } catch (error) {
    console.error("Error fetching revision count:", error);
    return 0;
  }
}

// Function to fetch revision history
async function fetchRevisionHistory(
  docId: string,
  token: string
): Promise<RevisionData[]> {
  const historyUrl = `https://docs.google.com/document/d/${docId}/revisions/load?id=${docId}&start=1&end=2`;

  try {
    const response = await fetch(historyUrl, {
      method: "GET",
      headers: {
        Authorization: `Bearer ${token}`,
        Accept: "application/json",
      },
    });

    if (!response.ok) {
      throw new Error(
        `Failed to fetch revision history: ${response.status} ${response.statusText}`
      );
    }

    const responseData = await response.json();
    return cleanRevisionData(responseData.changelog || []);
  } catch (error) {
    console.error("Error fetching revision history:", error);
    return [];
  }
}

// Cleans and structures raw revision data
function cleanRevisionData(rawData: any[]): RevisionData[] {
  return rawData.map((item: any) => ({
    ty: item.ty,
    timestamp: item.timestamp ?? 0,
    s: item.s || "",
    ibi: item.ibi,
    si: item.si,
    ei: item.ei,
    pasted: item.s ? item.s.split(" ").length >= 4 : false,
    outsidePasted: -1, // Default, to be updated later
    elapsedTime: 0, // To be calculated
    isDeleted: false,
  }));
}

// Computes elapsed time per character typed
function computeElapsedTime(revisionData: RevisionData[]): RevisionData[] {
  if (revisionData.length === 0) return [];

  const initialTimestamp = revisionData[0].timestamp;

  return revisionData.map((entry, index) => {
    const previousTimestamp =
      index > 0 ? revisionData[index - 1].timestamp : initialTimestamp;
    let elapsedTime = (entry.timestamp - previousTimestamp) / 1000 / 60; // Convert to minutes

    // Limit large gaps (>2 minutes) to avoid counting idle time
    if (elapsedTime > 2) elapsedTime = 0;

    return { ...entry, elapsedTime };
  });
}

// Calculate total time spent on the paper
function calculateTotalElapsedTime(revisionData: RevisionData[]): TimeStats {
  if (revisionData.length === 0)
    return { hours: 0, minutes: 0, rawElapsedTime: 0 };

  const totalElapsedTime = revisionData.reduce(
    (sum, item) => sum + (item.elapsedTime || 0),
    0
  );

  return {
    hours: Math.floor(totalElapsedTime / 60),
    minutes: Math.floor(totalElapsedTime % 60),
    rawElapsedTime: totalElapsedTime,
  };
}

// Detects and marks pasted text
function detectPastedText(revisionData: RevisionData[]): RevisionData[] {
  return revisionData.map((entry) => {
    if (entry.pasted) return { ...entry, outsidePasted: 1 };
    return entry;
  });
}

// Calculate percentage of pasted content
function calculatePastedPercent(revisionData: RevisionData[]): number {
  let totalChars = 0;
  let pastedChars = 0;

  revisionData.forEach((entry) => {
    if (!entry.isDeleted) {
      totalChars++;
      if (entry.outsidePasted === 1) pastedChars++;
    }
  });

  return totalChars === 0 ? 0 : Math.round((pastedChars / totalChars) * 100);
}

// Calculate words per minute
function calculateWordsPerMinute(revisionData: RevisionData[]): number {
  let totalElapsedTime = calculateTotalElapsedTime(revisionData).rawElapsedTime;
  let charCount = revisionData.reduce(
    (count, entry) =>
      entry.ty === "is" ? count + (entry.s?.length || 0) : count,
    0
  );

  return totalElapsedTime > 0
    ? Math.round(charCount / 5 / totalElapsedTime)
    : 0; // Assuming 5 characters per word
}

// Main function to process all statistics
export async function calculateCopy(docId: string, token: string) {
  let revisionData = await fetchRevisionHistory(docId, token);
  revisionData = computeElapsedTime(revisionData);
  revisionData = detectPastedText(revisionData);

  const totalElapsedTime = calculateTotalElapsedTime(revisionData);
  const pastedPercent = calculatePastedPercent(revisionData);
  const wordsPerMinute = calculateWordsPerMinute(revisionData);

  return {
    totalElapsedTime,
    pastedPercent,
    wordsPerMinute,
  };
}

(async () => {
  const docId = "1FD4A2TCecTWaDxUOAq9nrDIp_TLcZGNA8Y_gSrj8FBE";
  const token =
    "ya29.a0AXeO80R3WfX3Ze076wKYapXHzghXVivkiiGDWEYQcKmKEi210dbjlwewTZXhjDvasZx887db_FNfUGoT220PJ0OO0Fqb0RDWQjXHlnWezUdKSCk1CTP9HbvNlIfTCZAdjJbW7sIu7uEAl3BZudPbtifpQIoinZA2cfk6eXHXKkfswgB5oM6Imo1fUgaCgYKAQ8SARISFQHGX2MifGCCz3Y4YzYtjD5gG3Pw-A0193";

  const stats = await calculateCopy(docId, token);
  console.log("ðŸ“Š Document Stats:", stats);
})();
